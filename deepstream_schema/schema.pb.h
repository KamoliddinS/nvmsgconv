// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: schema.proto

#ifndef PROTOBUF_INCLUDED_schema_2eproto
#define PROTOBUF_INCLUDED_schema_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_schema_2eproto 

namespace protobuf_schema_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[22];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_schema_2eproto
namespace nv {
class AnalyticsModule;
class AnalyticsModuleDefaultTypeInternal;
extern AnalyticsModuleDefaultTypeInternal _AnalyticsModule_default_instance_;
class AnalyticsModule_InfoEntry_DoNotUse;
class AnalyticsModule_InfoEntry_DoNotUseDefaultTypeInternal;
extern AnalyticsModule_InfoEntry_DoNotUseDefaultTypeInternal _AnalyticsModule_InfoEntry_DoNotUse_default_instance_;
class Bbox;
class BboxDefaultTypeInternal;
extern BboxDefaultTypeInternal _Bbox_default_instance_;
class Coordinate;
class CoordinateDefaultTypeInternal;
extern CoordinateDefaultTypeInternal _Coordinate_default_instance_;
class Embedding;
class EmbeddingDefaultTypeInternal;
extern EmbeddingDefaultTypeInternal _Embedding_default_instance_;
class Embedding_InfoEntry_DoNotUse;
class Embedding_InfoEntry_DoNotUseDefaultTypeInternal;
extern Embedding_InfoEntry_DoNotUseDefaultTypeInternal _Embedding_InfoEntry_DoNotUse_default_instance_;
class Event;
class EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class Event_InfoEntry_DoNotUse;
class Event_InfoEntry_DoNotUseDefaultTypeInternal;
extern Event_InfoEntry_DoNotUseDefaultTypeInternal _Event_InfoEntry_DoNotUse_default_instance_;
class Frame;
class FrameDefaultTypeInternal;
extern FrameDefaultTypeInternal _Frame_default_instance_;
class Gaze;
class GazeDefaultTypeInternal;
extern GazeDefaultTypeInternal _Gaze_default_instance_;
class LipActivity;
class LipActivityDefaultTypeInternal;
extern LipActivityDefaultTypeInternal _LipActivity_default_instance_;
class Location;
class LocationDefaultTypeInternal;
extern LocationDefaultTypeInternal _Location_default_instance_;
class Message;
class MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class Object;
class ObjectDefaultTypeInternal;
extern ObjectDefaultTypeInternal _Object_default_instance_;
class Object_InfoEntry_DoNotUse;
class Object_InfoEntry_DoNotUseDefaultTypeInternal;
extern Object_InfoEntry_DoNotUseDefaultTypeInternal _Object_InfoEntry_DoNotUse_default_instance_;
class Place;
class PlaceDefaultTypeInternal;
extern PlaceDefaultTypeInternal _Place_default_instance_;
class Place_InfoEntry_DoNotUse;
class Place_InfoEntry_DoNotUseDefaultTypeInternal;
extern Place_InfoEntry_DoNotUseDefaultTypeInternal _Place_InfoEntry_DoNotUse_default_instance_;
class Pose;
class PoseDefaultTypeInternal;
extern PoseDefaultTypeInternal _Pose_default_instance_;
class Pose_Action;
class Pose_ActionDefaultTypeInternal;
extern Pose_ActionDefaultTypeInternal _Pose_Action_default_instance_;
class Pose_Keypoint;
class Pose_KeypointDefaultTypeInternal;
extern Pose_KeypointDefaultTypeInternal _Pose_Keypoint_default_instance_;
class Sensor;
class SensorDefaultTypeInternal;
extern SensorDefaultTypeInternal _Sensor_default_instance_;
class Sensor_InfoEntry_DoNotUse;
class Sensor_InfoEntry_DoNotUseDefaultTypeInternal;
extern Sensor_InfoEntry_DoNotUseDefaultTypeInternal _Sensor_InfoEntry_DoNotUse_default_instance_;
}  // namespace nv
namespace google {
namespace protobuf {
template<> ::nv::AnalyticsModule* Arena::CreateMaybeMessage<::nv::AnalyticsModule>(Arena*);
template<> ::nv::AnalyticsModule_InfoEntry_DoNotUse* Arena::CreateMaybeMessage<::nv::AnalyticsModule_InfoEntry_DoNotUse>(Arena*);
template<> ::nv::Bbox* Arena::CreateMaybeMessage<::nv::Bbox>(Arena*);
template<> ::nv::Coordinate* Arena::CreateMaybeMessage<::nv::Coordinate>(Arena*);
template<> ::nv::Embedding* Arena::CreateMaybeMessage<::nv::Embedding>(Arena*);
template<> ::nv::Embedding_InfoEntry_DoNotUse* Arena::CreateMaybeMessage<::nv::Embedding_InfoEntry_DoNotUse>(Arena*);
template<> ::nv::Event* Arena::CreateMaybeMessage<::nv::Event>(Arena*);
template<> ::nv::Event_InfoEntry_DoNotUse* Arena::CreateMaybeMessage<::nv::Event_InfoEntry_DoNotUse>(Arena*);
template<> ::nv::Frame* Arena::CreateMaybeMessage<::nv::Frame>(Arena*);
template<> ::nv::Gaze* Arena::CreateMaybeMessage<::nv::Gaze>(Arena*);
template<> ::nv::LipActivity* Arena::CreateMaybeMessage<::nv::LipActivity>(Arena*);
template<> ::nv::Location* Arena::CreateMaybeMessage<::nv::Location>(Arena*);
template<> ::nv::Message* Arena::CreateMaybeMessage<::nv::Message>(Arena*);
template<> ::nv::Object* Arena::CreateMaybeMessage<::nv::Object>(Arena*);
template<> ::nv::Object_InfoEntry_DoNotUse* Arena::CreateMaybeMessage<::nv::Object_InfoEntry_DoNotUse>(Arena*);
template<> ::nv::Place* Arena::CreateMaybeMessage<::nv::Place>(Arena*);
template<> ::nv::Place_InfoEntry_DoNotUse* Arena::CreateMaybeMessage<::nv::Place_InfoEntry_DoNotUse>(Arena*);
template<> ::nv::Pose* Arena::CreateMaybeMessage<::nv::Pose>(Arena*);
template<> ::nv::Pose_Action* Arena::CreateMaybeMessage<::nv::Pose_Action>(Arena*);
template<> ::nv::Pose_Keypoint* Arena::CreateMaybeMessage<::nv::Pose_Keypoint>(Arena*);
template<> ::nv::Sensor* Arena::CreateMaybeMessage<::nv::Sensor>(Arena*);
template<> ::nv::Sensor_InfoEntry_DoNotUse* Arena::CreateMaybeMessage<::nv::Sensor_InfoEntry_DoNotUse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace nv {

// ===================================================================

class Frame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nv.Frame) */ {
 public:
  Frame();
  virtual ~Frame();

  Frame(const Frame& from);

  inline Frame& operator=(const Frame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Frame(Frame&& from) noexcept
    : Frame() {
    *this = ::std::move(from);
  }

  inline Frame& operator=(Frame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Frame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Frame* internal_default_instance() {
    return reinterpret_cast<const Frame*>(
               &_Frame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Frame* other);
  friend void swap(Frame& a, Frame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Frame* New() const final {
    return CreateMaybeMessage<Frame>(NULL);
  }

  Frame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Frame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Frame& from);
  void MergeFrom(const Frame& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Frame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nv.Object objects = 5;
  int objects_size() const;
  void clear_objects();
  static const int kObjectsFieldNumber = 5;
  ::nv::Object* mutable_objects(int index);
  ::google::protobuf::RepeatedPtrField< ::nv::Object >*
      mutable_objects();
  const ::nv::Object& objects(int index) const;
  ::nv::Object* add_objects();
  const ::google::protobuf::RepeatedPtrField< ::nv::Object >&
      objects() const;

  // string version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string id = 2;
  void clear_id();
  static const int kIdFieldNumber = 2;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string sensorId = 4;
  void clear_sensorid();
  static const int kSensorIdFieldNumber = 4;
  const ::std::string& sensorid() const;
  void set_sensorid(const ::std::string& value);
  #if LANG_CXX11
  void set_sensorid(::std::string&& value);
  #endif
  void set_sensorid(const char* value);
  void set_sensorid(const char* value, size_t size);
  ::std::string* mutable_sensorid();
  ::std::string* release_sensorid();
  void set_allocated_sensorid(::std::string* sensorid);

  // .google.protobuf.Timestamp timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  private:
  const ::google::protobuf::Timestamp& _internal_timestamp() const;
  public:
  const ::google::protobuf::Timestamp& timestamp() const;
  ::google::protobuf::Timestamp* release_timestamp();
  ::google::protobuf::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* timestamp);

  // @@protoc_insertion_point(class_scope:nv.Frame)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nv::Object > objects_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr sensorid_;
  ::google::protobuf::Timestamp* timestamp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Object_InfoEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Object_InfoEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Object_InfoEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  Object_InfoEntry_DoNotUse();
  Object_InfoEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Object_InfoEntry_DoNotUse& other);
  static const Object_InfoEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Object_InfoEntry_DoNotUse*>(&_Object_InfoEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Object : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nv.Object) */ {
 public:
  Object();
  virtual ~Object();

  Object(const Object& from);

  inline Object& operator=(const Object& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Object(Object&& from) noexcept
    : Object() {
    *this = ::std::move(from);
  }

  inline Object& operator=(Object&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Object& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Object* internal_default_instance() {
    return reinterpret_cast<const Object*>(
               &_Object_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Object* other);
  friend void swap(Object& a, Object& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Object* New() const final {
    return CreateMaybeMessage<Object>(NULL);
  }

  Object* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Object>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Object& from);
  void MergeFrom(const Object& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Object* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> info = 5;
  int info_size() const;
  void clear_info();
  static const int kInfoFieldNumber = 5;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      info() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_info();

  // repeated float dir = 11;
  int dir_size() const;
  void clear_dir();
  static const int kDirFieldNumber = 11;
  float dir(int index) const;
  void set_dir(int index, float value);
  void add_dir(float value);
  const ::google::protobuf::RepeatedField< float >&
      dir() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_dir();

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // .nv.Bbox bbox = 2;
  bool has_bbox() const;
  void clear_bbox();
  static const int kBboxFieldNumber = 2;
  private:
  const ::nv::Bbox& _internal_bbox() const;
  public:
  const ::nv::Bbox& bbox() const;
  ::nv::Bbox* release_bbox();
  ::nv::Bbox* mutable_bbox();
  void set_allocated_bbox(::nv::Bbox* bbox);

  // .nv.Embedding embedding = 6;
  bool has_embedding() const;
  void clear_embedding();
  static const int kEmbeddingFieldNumber = 6;
  private:
  const ::nv::Embedding& _internal_embedding() const;
  public:
  const ::nv::Embedding& embedding() const;
  ::nv::Embedding* release_embedding();
  ::nv::Embedding* mutable_embedding();
  void set_allocated_embedding(::nv::Embedding* embedding);

  // .nv.Pose pose = 7;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 7;
  private:
  const ::nv::Pose& _internal_pose() const;
  public:
  const ::nv::Pose& pose() const;
  ::nv::Pose* release_pose();
  ::nv::Pose* mutable_pose();
  void set_allocated_pose(::nv::Pose* pose);

  // .nv.Gaze gaze = 8;
  bool has_gaze() const;
  void clear_gaze();
  static const int kGazeFieldNumber = 8;
  private:
  const ::nv::Gaze& _internal_gaze() const;
  public:
  const ::nv::Gaze& gaze() const;
  ::nv::Gaze* release_gaze();
  ::nv::Gaze* mutable_gaze();
  void set_allocated_gaze(::nv::Gaze* gaze);

  // .nv.LipActivity lipActivity = 9;
  bool has_lipactivity() const;
  void clear_lipactivity();
  static const int kLipActivityFieldNumber = 9;
  private:
  const ::nv::LipActivity& _internal_lipactivity() const;
  public:
  const ::nv::LipActivity& lipactivity() const;
  ::nv::LipActivity* release_lipactivity();
  ::nv::LipActivity* mutable_lipactivity();
  void set_allocated_lipactivity(::nv::LipActivity* lipactivity);

  // .nv.Coordinate coordinate = 12;
  bool has_coordinate() const;
  void clear_coordinate();
  static const int kCoordinateFieldNumber = 12;
  private:
  const ::nv::Coordinate& _internal_coordinate() const;
  public:
  const ::nv::Coordinate& coordinate() const;
  ::nv::Coordinate* release_coordinate();
  ::nv::Coordinate* mutable_coordinate();
  void set_allocated_coordinate(::nv::Coordinate* coordinate);

  // .nv.Location location = 13;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 13;
  private:
  const ::nv::Location& _internal_location() const;
  public:
  const ::nv::Location& location() const;
  ::nv::Location* release_location();
  ::nv::Location* mutable_location();
  void set_allocated_location(::nv::Location* location);

  // float confidence = 4;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 4;
  float confidence() const;
  void set_confidence(float value);

  // float speed = 10;
  void clear_speed();
  static const int kSpeedFieldNumber = 10;
  float speed() const;
  void set_speed(float value);

  // @@protoc_insertion_point(class_scope:nv.Object)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      Object_InfoEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > info_;
  ::google::protobuf::RepeatedField< float > dir_;
  mutable int _dir_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::nv::Bbox* bbox_;
  ::nv::Embedding* embedding_;
  ::nv::Pose* pose_;
  ::nv::Gaze* gaze_;
  ::nv::LipActivity* lipactivity_;
  ::nv::Coordinate* coordinate_;
  ::nv::Location* location_;
  float confidence_;
  float speed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Coordinate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nv.Coordinate) */ {
 public:
  Coordinate();
  virtual ~Coordinate();

  Coordinate(const Coordinate& from);

  inline Coordinate& operator=(const Coordinate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Coordinate(Coordinate&& from) noexcept
    : Coordinate() {
    *this = ::std::move(from);
  }

  inline Coordinate& operator=(Coordinate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Coordinate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Coordinate* internal_default_instance() {
    return reinterpret_cast<const Coordinate*>(
               &_Coordinate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Coordinate* other);
  friend void swap(Coordinate& a, Coordinate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Coordinate* New() const final {
    return CreateMaybeMessage<Coordinate>(NULL);
  }

  Coordinate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Coordinate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Coordinate& from);
  void MergeFrom(const Coordinate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Coordinate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // double y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // double z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:nv.Coordinate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double x_;
  double y_;
  double z_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Location : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nv.Location) */ {
 public:
  Location();
  virtual ~Location();

  Location(const Location& from);

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Location(Location&& from) noexcept
    : Location() {
    *this = ::std::move(from);
  }

  inline Location& operator=(Location&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Location& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Location* internal_default_instance() {
    return reinterpret_cast<const Location*>(
               &_Location_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Location* other);
  friend void swap(Location& a, Location& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Location* New() const final {
    return CreateMaybeMessage<Location>(NULL);
  }

  Location* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Location>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Location& from);
  void MergeFrom(const Location& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Location* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double lat = 1;
  void clear_lat();
  static const int kLatFieldNumber = 1;
  double lat() const;
  void set_lat(double value);

  // double lon = 2;
  void clear_lon();
  static const int kLonFieldNumber = 2;
  double lon() const;
  void set_lon(double value);

  // double alt = 3;
  void clear_alt();
  static const int kAltFieldNumber = 3;
  double alt() const;
  void set_alt(double value);

  // @@protoc_insertion_point(class_scope:nv.Location)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double lat_;
  double lon_;
  double alt_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Bbox : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nv.Bbox) */ {
 public:
  Bbox();
  virtual ~Bbox();

  Bbox(const Bbox& from);

  inline Bbox& operator=(const Bbox& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Bbox(Bbox&& from) noexcept
    : Bbox() {
    *this = ::std::move(from);
  }

  inline Bbox& operator=(Bbox&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Bbox& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Bbox* internal_default_instance() {
    return reinterpret_cast<const Bbox*>(
               &_Bbox_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Bbox* other);
  friend void swap(Bbox& a, Bbox& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Bbox* New() const final {
    return CreateMaybeMessage<Bbox>(NULL);
  }

  Bbox* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Bbox>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Bbox& from);
  void MergeFrom(const Bbox& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Bbox* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float leftX = 1;
  void clear_leftx();
  static const int kLeftXFieldNumber = 1;
  float leftx() const;
  void set_leftx(float value);

  // float topY = 2;
  void clear_topy();
  static const int kTopYFieldNumber = 2;
  float topy() const;
  void set_topy(float value);

  // float rightX = 3;
  void clear_rightx();
  static const int kRightXFieldNumber = 3;
  float rightx() const;
  void set_rightx(float value);

  // float bottomY = 4;
  void clear_bottomy();
  static const int kBottomYFieldNumber = 4;
  float bottomy() const;
  void set_bottomy(float value);

  // @@protoc_insertion_point(class_scope:nv.Bbox)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float leftx_;
  float topy_;
  float rightx_;
  float bottomy_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Pose_Keypoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nv.Pose.Keypoint) */ {
 public:
  Pose_Keypoint();
  virtual ~Pose_Keypoint();

  Pose_Keypoint(const Pose_Keypoint& from);

  inline Pose_Keypoint& operator=(const Pose_Keypoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Pose_Keypoint(Pose_Keypoint&& from) noexcept
    : Pose_Keypoint() {
    *this = ::std::move(from);
  }

  inline Pose_Keypoint& operator=(Pose_Keypoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Pose_Keypoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Pose_Keypoint* internal_default_instance() {
    return reinterpret_cast<const Pose_Keypoint*>(
               &_Pose_Keypoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Pose_Keypoint* other);
  friend void swap(Pose_Keypoint& a, Pose_Keypoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Pose_Keypoint* New() const final {
    return CreateMaybeMessage<Pose_Keypoint>(NULL);
  }

  Pose_Keypoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Pose_Keypoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Pose_Keypoint& from);
  void MergeFrom(const Pose_Keypoint& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pose_Keypoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float coordinates = 2;
  int coordinates_size() const;
  void clear_coordinates();
  static const int kCoordinatesFieldNumber = 2;
  float coordinates(int index) const;
  void set_coordinates(int index, float value);
  void add_coordinates(float value);
  const ::google::protobuf::RepeatedField< float >&
      coordinates() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_coordinates();

  // repeated float quaternion = 3;
  int quaternion_size() const;
  void clear_quaternion();
  static const int kQuaternionFieldNumber = 3;
  float quaternion(int index) const;
  void set_quaternion(int index, float value);
  void add_quaternion(float value);
  const ::google::protobuf::RepeatedField< float >&
      quaternion() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_quaternion();

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:nv.Pose.Keypoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > coordinates_;
  mutable int _coordinates_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > quaternion_;
  mutable int _quaternion_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Pose_Action : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nv.Pose.Action) */ {
 public:
  Pose_Action();
  virtual ~Pose_Action();

  Pose_Action(const Pose_Action& from);

  inline Pose_Action& operator=(const Pose_Action& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Pose_Action(Pose_Action&& from) noexcept
    : Pose_Action() {
    *this = ::std::move(from);
  }

  inline Pose_Action& operator=(Pose_Action&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Pose_Action& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Pose_Action* internal_default_instance() {
    return reinterpret_cast<const Pose_Action*>(
               &_Pose_Action_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Pose_Action* other);
  friend void swap(Pose_Action& a, Pose_Action& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Pose_Action* New() const final {
    return CreateMaybeMessage<Pose_Action>(NULL);
  }

  Pose_Action* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Pose_Action>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Pose_Action& from);
  void MergeFrom(const Pose_Action& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pose_Action* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // float confidence = 2;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  float confidence() const;
  void set_confidence(float value);

  // @@protoc_insertion_point(class_scope:nv.Pose.Action)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  float confidence_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Pose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nv.Pose) */ {
 public:
  Pose();
  virtual ~Pose();

  Pose(const Pose& from);

  inline Pose& operator=(const Pose& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Pose(Pose&& from) noexcept
    : Pose() {
    *this = ::std::move(from);
  }

  inline Pose& operator=(Pose&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Pose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Pose* internal_default_instance() {
    return reinterpret_cast<const Pose*>(
               &_Pose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Pose* other);
  friend void swap(Pose& a, Pose& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Pose* New() const final {
    return CreateMaybeMessage<Pose>(NULL);
  }

  Pose* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Pose>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Pose& from);
  void MergeFrom(const Pose& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Pose_Keypoint Keypoint;
  typedef Pose_Action Action;

  // accessors -------------------------------------------------------

  // repeated .nv.Pose.Keypoint keypoints = 2;
  int keypoints_size() const;
  void clear_keypoints();
  static const int kKeypointsFieldNumber = 2;
  ::nv::Pose_Keypoint* mutable_keypoints(int index);
  ::google::protobuf::RepeatedPtrField< ::nv::Pose_Keypoint >*
      mutable_keypoints();
  const ::nv::Pose_Keypoint& keypoints(int index) const;
  ::nv::Pose_Keypoint* add_keypoints();
  const ::google::protobuf::RepeatedPtrField< ::nv::Pose_Keypoint >&
      keypoints() const;

  // repeated .nv.Pose.Action actions = 3;
  int actions_size() const;
  void clear_actions();
  static const int kActionsFieldNumber = 3;
  ::nv::Pose_Action* mutable_actions(int index);
  ::google::protobuf::RepeatedPtrField< ::nv::Pose_Action >*
      mutable_actions();
  const ::nv::Pose_Action& actions(int index) const;
  ::nv::Pose_Action* add_actions();
  const ::google::protobuf::RepeatedPtrField< ::nv::Pose_Action >&
      actions() const;

  // string type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:nv.Pose)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nv::Pose_Keypoint > keypoints_;
  ::google::protobuf::RepeatedPtrField< ::nv::Pose_Action > actions_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Gaze : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nv.Gaze) */ {
 public:
  Gaze();
  virtual ~Gaze();

  Gaze(const Gaze& from);

  inline Gaze& operator=(const Gaze& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Gaze(Gaze&& from) noexcept
    : Gaze() {
    *this = ::std::move(from);
  }

  inline Gaze& operator=(Gaze&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Gaze& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Gaze* internal_default_instance() {
    return reinterpret_cast<const Gaze*>(
               &_Gaze_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Gaze* other);
  friend void swap(Gaze& a, Gaze& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Gaze* New() const final {
    return CreateMaybeMessage<Gaze>(NULL);
  }

  Gaze* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Gaze>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Gaze& from);
  void MergeFrom(const Gaze& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Gaze* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // float z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // float theta = 4;
  void clear_theta();
  static const int kThetaFieldNumber = 4;
  float theta() const;
  void set_theta(float value);

  // float phi = 5;
  void clear_phi();
  static const int kPhiFieldNumber = 5;
  float phi() const;
  void set_phi(float value);

  // @@protoc_insertion_point(class_scope:nv.Gaze)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float z_;
  float theta_;
  float phi_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LipActivity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nv.LipActivity) */ {
 public:
  LipActivity();
  virtual ~LipActivity();

  LipActivity(const LipActivity& from);

  inline LipActivity& operator=(const LipActivity& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LipActivity(LipActivity&& from) noexcept
    : LipActivity() {
    *this = ::std::move(from);
  }

  inline LipActivity& operator=(LipActivity&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LipActivity& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LipActivity* internal_default_instance() {
    return reinterpret_cast<const LipActivity*>(
               &_LipActivity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(LipActivity* other);
  friend void swap(LipActivity& a, LipActivity& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LipActivity* New() const final {
    return CreateMaybeMessage<LipActivity>(NULL);
  }

  LipActivity* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LipActivity>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LipActivity& from);
  void MergeFrom(const LipActivity& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LipActivity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string classLabel = 1;
  void clear_classlabel();
  static const int kClassLabelFieldNumber = 1;
  const ::std::string& classlabel() const;
  void set_classlabel(const ::std::string& value);
  #if LANG_CXX11
  void set_classlabel(::std::string&& value);
  #endif
  void set_classlabel(const char* value);
  void set_classlabel(const char* value, size_t size);
  ::std::string* mutable_classlabel();
  ::std::string* release_classlabel();
  void set_allocated_classlabel(::std::string* classlabel);

  // @@protoc_insertion_point(class_scope:nv.LipActivity)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr classlabel_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Event_InfoEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Event_InfoEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Event_InfoEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  Event_InfoEntry_DoNotUse();
  Event_InfoEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Event_InfoEntry_DoNotUse& other);
  static const Event_InfoEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Event_InfoEntry_DoNotUse*>(&_Event_InfoEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Event : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nv.Event) */ {
 public:
  Event();
  virtual ~Event();

  Event(const Event& from);

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(Event&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(Event* other);
  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event* New() const final {
    return CreateMaybeMessage<Event>(NULL);
  }

  Event* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> info = 5;
  int info_size() const;
  void clear_info();
  static const int kInfoFieldNumber = 5;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      info() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_info();

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:nv.Event)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      Event_InfoEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > info_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AnalyticsModule_InfoEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<AnalyticsModule_InfoEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<AnalyticsModule_InfoEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  AnalyticsModule_InfoEntry_DoNotUse();
  AnalyticsModule_InfoEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const AnalyticsModule_InfoEntry_DoNotUse& other);
  static const AnalyticsModule_InfoEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AnalyticsModule_InfoEntry_DoNotUse*>(&_AnalyticsModule_InfoEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class AnalyticsModule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nv.AnalyticsModule) */ {
 public:
  AnalyticsModule();
  virtual ~AnalyticsModule();

  AnalyticsModule(const AnalyticsModule& from);

  inline AnalyticsModule& operator=(const AnalyticsModule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AnalyticsModule(AnalyticsModule&& from) noexcept
    : AnalyticsModule() {
    *this = ::std::move(from);
  }

  inline AnalyticsModule& operator=(AnalyticsModule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AnalyticsModule& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnalyticsModule* internal_default_instance() {
    return reinterpret_cast<const AnalyticsModule*>(
               &_AnalyticsModule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(AnalyticsModule* other);
  friend void swap(AnalyticsModule& a, AnalyticsModule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AnalyticsModule* New() const final {
    return CreateMaybeMessage<AnalyticsModule>(NULL);
  }

  AnalyticsModule* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AnalyticsModule>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AnalyticsModule& from);
  void MergeFrom(const AnalyticsModule& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnalyticsModule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> info = 5;
  int info_size() const;
  void clear_info();
  static const int kInfoFieldNumber = 5;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      info() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_info();

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string description = 2;
  void clear_description();
  static const int kDescriptionFieldNumber = 2;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // string source = 3;
  void clear_source();
  static const int kSourceFieldNumber = 3;
  const ::std::string& source() const;
  void set_source(const ::std::string& value);
  #if LANG_CXX11
  void set_source(::std::string&& value);
  #endif
  void set_source(const char* value);
  void set_source(const char* value, size_t size);
  ::std::string* mutable_source();
  ::std::string* release_source();
  void set_allocated_source(::std::string* source);

  // string version = 4;
  void clear_version();
  static const int kVersionFieldNumber = 4;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:nv.AnalyticsModule)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      AnalyticsModule_InfoEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > info_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr source_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Sensor_InfoEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Sensor_InfoEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Sensor_InfoEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  Sensor_InfoEntry_DoNotUse();
  Sensor_InfoEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Sensor_InfoEntry_DoNotUse& other);
  static const Sensor_InfoEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Sensor_InfoEntry_DoNotUse*>(&_Sensor_InfoEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Sensor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nv.Sensor) */ {
 public:
  Sensor();
  virtual ~Sensor();

  Sensor(const Sensor& from);

  inline Sensor& operator=(const Sensor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sensor(Sensor&& from) noexcept
    : Sensor() {
    *this = ::std::move(from);
  }

  inline Sensor& operator=(Sensor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Sensor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sensor* internal_default_instance() {
    return reinterpret_cast<const Sensor*>(
               &_Sensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(Sensor* other);
  friend void swap(Sensor& a, Sensor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sensor* New() const final {
    return CreateMaybeMessage<Sensor>(NULL);
  }

  Sensor* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Sensor>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Sensor& from);
  void MergeFrom(const Sensor& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sensor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> info = 6;
  int info_size() const;
  void clear_info();
  static const int kInfoFieldNumber = 6;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      info() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_info();

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // string description = 3;
  void clear_description();
  static const int kDescriptionFieldNumber = 3;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // .nv.Location location = 4;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 4;
  private:
  const ::nv::Location& _internal_location() const;
  public:
  const ::nv::Location& location() const;
  ::nv::Location* release_location();
  ::nv::Location* mutable_location();
  void set_allocated_location(::nv::Location* location);

  // .nv.Coordinate coordinate = 5;
  bool has_coordinate() const;
  void clear_coordinate();
  static const int kCoordinateFieldNumber = 5;
  private:
  const ::nv::Coordinate& _internal_coordinate() const;
  public:
  const ::nv::Coordinate& coordinate() const;
  ::nv::Coordinate* release_coordinate();
  ::nv::Coordinate* mutable_coordinate();
  void set_allocated_coordinate(::nv::Coordinate* coordinate);

  // @@protoc_insertion_point(class_scope:nv.Sensor)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      Sensor_InfoEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > info_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::nv::Location* location_;
  ::nv::Coordinate* coordinate_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Place_InfoEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Place_InfoEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Place_InfoEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  Place_InfoEntry_DoNotUse();
  Place_InfoEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Place_InfoEntry_DoNotUse& other);
  static const Place_InfoEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Place_InfoEntry_DoNotUse*>(&_Place_InfoEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Place : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nv.Place) */ {
 public:
  Place();
  virtual ~Place();

  Place(const Place& from);

  inline Place& operator=(const Place& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Place(Place&& from) noexcept
    : Place() {
    *this = ::std::move(from);
  }

  inline Place& operator=(Place&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Place& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Place* internal_default_instance() {
    return reinterpret_cast<const Place*>(
               &_Place_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(Place* other);
  friend void swap(Place& a, Place& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Place* New() const final {
    return CreateMaybeMessage<Place>(NULL);
  }

  Place* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Place>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Place& from);
  void MergeFrom(const Place& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Place* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> info = 6;
  int info_size() const;
  void clear_info();
  static const int kInfoFieldNumber = 6;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      info() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_info();

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // .nv.Location location = 4;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 4;
  private:
  const ::nv::Location& _internal_location() const;
  public:
  const ::nv::Location& location() const;
  ::nv::Location* release_location();
  ::nv::Location* mutable_location();
  void set_allocated_location(::nv::Location* location);

  // .nv.Coordinate coordinate = 5;
  bool has_coordinate() const;
  void clear_coordinate();
  static const int kCoordinateFieldNumber = 5;
  private:
  const ::nv::Coordinate& _internal_coordinate() const;
  public:
  const ::nv::Coordinate& coordinate() const;
  ::nv::Coordinate* release_coordinate();
  ::nv::Coordinate* mutable_coordinate();
  void set_allocated_coordinate(::nv::Coordinate* coordinate);

  // @@protoc_insertion_point(class_scope:nv.Place)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      Place_InfoEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > info_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::nv::Location* location_;
  ::nv::Coordinate* coordinate_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nv.Message) */ {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(Message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(Message* other);
  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Message* New() const final {
    return CreateMaybeMessage<Message>(NULL);
  }

  Message* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string messageid = 1;
  void clear_messageid();
  static const int kMessageidFieldNumber = 1;
  const ::std::string& messageid() const;
  void set_messageid(const ::std::string& value);
  #if LANG_CXX11
  void set_messageid(::std::string&& value);
  #endif
  void set_messageid(const char* value);
  void set_messageid(const char* value, size_t size);
  ::std::string* mutable_messageid();
  ::std::string* release_messageid();
  void set_allocated_messageid(::std::string* messageid);

  // string mdsversion = 2;
  void clear_mdsversion();
  static const int kMdsversionFieldNumber = 2;
  const ::std::string& mdsversion() const;
  void set_mdsversion(const ::std::string& value);
  #if LANG_CXX11
  void set_mdsversion(::std::string&& value);
  #endif
  void set_mdsversion(const char* value);
  void set_mdsversion(const char* value, size_t size);
  ::std::string* mutable_mdsversion();
  ::std::string* release_mdsversion();
  void set_allocated_mdsversion(::std::string* mdsversion);

  // string videoPath = 9;
  void clear_videopath();
  static const int kVideoPathFieldNumber = 9;
  const ::std::string& videopath() const;
  void set_videopath(const ::std::string& value);
  #if LANG_CXX11
  void set_videopath(::std::string&& value);
  #endif
  void set_videopath(const char* value);
  void set_videopath(const char* value, size_t size);
  ::std::string* mutable_videopath();
  ::std::string* release_videopath();
  void set_allocated_videopath(::std::string* videopath);

  // .google.protobuf.Timestamp timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  private:
  const ::google::protobuf::Timestamp& _internal_timestamp() const;
  public:
  const ::google::protobuf::Timestamp& timestamp() const;
  ::google::protobuf::Timestamp* release_timestamp();
  ::google::protobuf::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* timestamp);

  // .nv.Place place = 4;
  bool has_place() const;
  void clear_place();
  static const int kPlaceFieldNumber = 4;
  private:
  const ::nv::Place& _internal_place() const;
  public:
  const ::nv::Place& place() const;
  ::nv::Place* release_place();
  ::nv::Place* mutable_place();
  void set_allocated_place(::nv::Place* place);

  // .nv.Sensor sensor = 5;
  bool has_sensor() const;
  void clear_sensor();
  static const int kSensorFieldNumber = 5;
  private:
  const ::nv::Sensor& _internal_sensor() const;
  public:
  const ::nv::Sensor& sensor() const;
  ::nv::Sensor* release_sensor();
  ::nv::Sensor* mutable_sensor();
  void set_allocated_sensor(::nv::Sensor* sensor);

  // .nv.AnalyticsModule analyticsModule = 6;
  bool has_analyticsmodule() const;
  void clear_analyticsmodule();
  static const int kAnalyticsModuleFieldNumber = 6;
  private:
  const ::nv::AnalyticsModule& _internal_analyticsmodule() const;
  public:
  const ::nv::AnalyticsModule& analyticsmodule() const;
  ::nv::AnalyticsModule* release_analyticsmodule();
  ::nv::AnalyticsModule* mutable_analyticsmodule();
  void set_allocated_analyticsmodule(::nv::AnalyticsModule* analyticsmodule);

  // .nv.Object object = 7;
  bool has_object() const;
  void clear_object();
  static const int kObjectFieldNumber = 7;
  private:
  const ::nv::Object& _internal_object() const;
  public:
  const ::nv::Object& object() const;
  ::nv::Object* release_object();
  ::nv::Object* mutable_object();
  void set_allocated_object(::nv::Object* object);

  // .nv.Event event = 8;
  bool has_event() const;
  void clear_event();
  static const int kEventFieldNumber = 8;
  private:
  const ::nv::Event& _internal_event() const;
  public:
  const ::nv::Event& event() const;
  ::nv::Event* release_event();
  ::nv::Event* mutable_event();
  void set_allocated_event(::nv::Event* event);

  // @@protoc_insertion_point(class_scope:nv.Message)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr messageid_;
  ::google::protobuf::internal::ArenaStringPtr mdsversion_;
  ::google::protobuf::internal::ArenaStringPtr videopath_;
  ::google::protobuf::Timestamp* timestamp_;
  ::nv::Place* place_;
  ::nv::Sensor* sensor_;
  ::nv::AnalyticsModule* analyticsmodule_;
  ::nv::Object* object_;
  ::nv::Event* event_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Embedding_InfoEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Embedding_InfoEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Embedding_InfoEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  Embedding_InfoEntry_DoNotUse();
  Embedding_InfoEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Embedding_InfoEntry_DoNotUse& other);
  static const Embedding_InfoEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Embedding_InfoEntry_DoNotUse*>(&_Embedding_InfoEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Embedding : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nv.Embedding) */ {
 public:
  Embedding();
  virtual ~Embedding();

  Embedding(const Embedding& from);

  inline Embedding& operator=(const Embedding& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Embedding(Embedding&& from) noexcept
    : Embedding() {
    *this = ::std::move(from);
  }

  inline Embedding& operator=(Embedding&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Embedding& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Embedding* internal_default_instance() {
    return reinterpret_cast<const Embedding*>(
               &_Embedding_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(Embedding* other);
  friend void swap(Embedding& a, Embedding& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Embedding* New() const final {
    return CreateMaybeMessage<Embedding>(NULL);
  }

  Embedding* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Embedding>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Embedding& from);
  void MergeFrom(const Embedding& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Embedding* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // repeated float vector = 1 [packed = true];
  int vector_size() const;
  void clear_vector();
  static const int kVectorFieldNumber = 1;
  float vector(int index) const;
  void set_vector(int index, float value);
  void add_vector(float value);
  const ::google::protobuf::RepeatedField< float >&
      vector() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_vector();

  // map<string, string> info = 2;
  int info_size() const;
  void clear_info();
  static const int kInfoFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      info() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_info();

  // @@protoc_insertion_point(class_scope:nv.Embedding)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > vector_;
  mutable int _vector_cached_byte_size_;
  ::google::protobuf::internal::MapField<
      Embedding_InfoEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > info_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Frame

// string version = 1;
inline void Frame::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Frame::version() const {
  // @@protoc_insertion_point(field_get:nv.Frame.version)
  return version_.GetNoArena();
}
inline void Frame::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nv.Frame.version)
}
#if LANG_CXX11
inline void Frame::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nv.Frame.version)
}
#endif
inline void Frame::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nv.Frame.version)
}
inline void Frame::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nv.Frame.version)
}
inline ::std::string* Frame::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:nv.Frame.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Frame::release_version() {
  // @@protoc_insertion_point(field_release:nv.Frame.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Frame::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:nv.Frame.version)
}

// string id = 2;
inline void Frame::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Frame::id() const {
  // @@protoc_insertion_point(field_get:nv.Frame.id)
  return id_.GetNoArena();
}
inline void Frame::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nv.Frame.id)
}
#if LANG_CXX11
inline void Frame::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nv.Frame.id)
}
#endif
inline void Frame::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nv.Frame.id)
}
inline void Frame::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nv.Frame.id)
}
inline ::std::string* Frame::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:nv.Frame.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Frame::release_id() {
  // @@protoc_insertion_point(field_release:nv.Frame.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Frame::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:nv.Frame.id)
}

// .google.protobuf.Timestamp timestamp = 3;
inline bool Frame::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline const ::google::protobuf::Timestamp& Frame::_internal_timestamp() const {
  return *timestamp_;
}
inline const ::google::protobuf::Timestamp& Frame::timestamp() const {
  const ::google::protobuf::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:nv.Frame.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* Frame::release_timestamp() {
  // @@protoc_insertion_point(field_release:nv.Frame.timestamp)
  
  ::google::protobuf::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* Frame::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    timestamp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nv.Frame.timestamp)
  return timestamp_;
}
inline void Frame::set_allocated_timestamp(::google::protobuf::Timestamp* timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:nv.Frame.timestamp)
}

// string sensorId = 4;
inline void Frame::clear_sensorid() {
  sensorid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Frame::sensorid() const {
  // @@protoc_insertion_point(field_get:nv.Frame.sensorId)
  return sensorid_.GetNoArena();
}
inline void Frame::set_sensorid(const ::std::string& value) {
  
  sensorid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nv.Frame.sensorId)
}
#if LANG_CXX11
inline void Frame::set_sensorid(::std::string&& value) {
  
  sensorid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nv.Frame.sensorId)
}
#endif
inline void Frame::set_sensorid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sensorid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nv.Frame.sensorId)
}
inline void Frame::set_sensorid(const char* value, size_t size) {
  
  sensorid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nv.Frame.sensorId)
}
inline ::std::string* Frame::mutable_sensorid() {
  
  // @@protoc_insertion_point(field_mutable:nv.Frame.sensorId)
  return sensorid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Frame::release_sensorid() {
  // @@protoc_insertion_point(field_release:nv.Frame.sensorId)
  
  return sensorid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Frame::set_allocated_sensorid(::std::string* sensorid) {
  if (sensorid != NULL) {
    
  } else {
    
  }
  sensorid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sensorid);
  // @@protoc_insertion_point(field_set_allocated:nv.Frame.sensorId)
}

// repeated .nv.Object objects = 5;
inline int Frame::objects_size() const {
  return objects_.size();
}
inline void Frame::clear_objects() {
  objects_.Clear();
}
inline ::nv::Object* Frame::mutable_objects(int index) {
  // @@protoc_insertion_point(field_mutable:nv.Frame.objects)
  return objects_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nv::Object >*
Frame::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_list:nv.Frame.objects)
  return &objects_;
}
inline const ::nv::Object& Frame::objects(int index) const {
  // @@protoc_insertion_point(field_get:nv.Frame.objects)
  return objects_.Get(index);
}
inline ::nv::Object* Frame::add_objects() {
  // @@protoc_insertion_point(field_add:nv.Frame.objects)
  return objects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::Object >&
Frame::objects() const {
  // @@protoc_insertion_point(field_list:nv.Frame.objects)
  return objects_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Object

// string id = 1;
inline void Object::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Object::id() const {
  // @@protoc_insertion_point(field_get:nv.Object.id)
  return id_.GetNoArena();
}
inline void Object::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nv.Object.id)
}
#if LANG_CXX11
inline void Object::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nv.Object.id)
}
#endif
inline void Object::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nv.Object.id)
}
inline void Object::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nv.Object.id)
}
inline ::std::string* Object::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:nv.Object.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Object::release_id() {
  // @@protoc_insertion_point(field_release:nv.Object.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Object::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:nv.Object.id)
}

// .nv.Bbox bbox = 2;
inline bool Object::has_bbox() const {
  return this != internal_default_instance() && bbox_ != NULL;
}
inline void Object::clear_bbox() {
  if (GetArenaNoVirtual() == NULL && bbox_ != NULL) {
    delete bbox_;
  }
  bbox_ = NULL;
}
inline const ::nv::Bbox& Object::_internal_bbox() const {
  return *bbox_;
}
inline const ::nv::Bbox& Object::bbox() const {
  const ::nv::Bbox* p = bbox_;
  // @@protoc_insertion_point(field_get:nv.Object.bbox)
  return p != NULL ? *p : *reinterpret_cast<const ::nv::Bbox*>(
      &::nv::_Bbox_default_instance_);
}
inline ::nv::Bbox* Object::release_bbox() {
  // @@protoc_insertion_point(field_release:nv.Object.bbox)
  
  ::nv::Bbox* temp = bbox_;
  bbox_ = NULL;
  return temp;
}
inline ::nv::Bbox* Object::mutable_bbox() {
  
  if (bbox_ == NULL) {
    auto* p = CreateMaybeMessage<::nv::Bbox>(GetArenaNoVirtual());
    bbox_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nv.Object.bbox)
  return bbox_;
}
inline void Object::set_allocated_bbox(::nv::Bbox* bbox) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bbox_;
  }
  if (bbox) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bbox = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bbox, submessage_arena);
    }
    
  } else {
    
  }
  bbox_ = bbox;
  // @@protoc_insertion_point(field_set_allocated:nv.Object.bbox)
}

// string type = 3;
inline void Object::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Object::type() const {
  // @@protoc_insertion_point(field_get:nv.Object.type)
  return type_.GetNoArena();
}
inline void Object::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nv.Object.type)
}
#if LANG_CXX11
inline void Object::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nv.Object.type)
}
#endif
inline void Object::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nv.Object.type)
}
inline void Object::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nv.Object.type)
}
inline ::std::string* Object::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:nv.Object.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Object::release_type() {
  // @@protoc_insertion_point(field_release:nv.Object.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Object::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:nv.Object.type)
}

// float confidence = 4;
inline void Object::clear_confidence() {
  confidence_ = 0;
}
inline float Object::confidence() const {
  // @@protoc_insertion_point(field_get:nv.Object.confidence)
  return confidence_;
}
inline void Object::set_confidence(float value) {
  
  confidence_ = value;
  // @@protoc_insertion_point(field_set:nv.Object.confidence)
}

// map<string, string> info = 5;
inline int Object::info_size() const {
  return info_.size();
}
inline void Object::clear_info() {
  info_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
Object::info() const {
  // @@protoc_insertion_point(field_map:nv.Object.info)
  return info_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
Object::mutable_info() {
  // @@protoc_insertion_point(field_mutable_map:nv.Object.info)
  return info_.MutableMap();
}

// .nv.Embedding embedding = 6;
inline bool Object::has_embedding() const {
  return this != internal_default_instance() && embedding_ != NULL;
}
inline void Object::clear_embedding() {
  if (GetArenaNoVirtual() == NULL && embedding_ != NULL) {
    delete embedding_;
  }
  embedding_ = NULL;
}
inline const ::nv::Embedding& Object::_internal_embedding() const {
  return *embedding_;
}
inline const ::nv::Embedding& Object::embedding() const {
  const ::nv::Embedding* p = embedding_;
  // @@protoc_insertion_point(field_get:nv.Object.embedding)
  return p != NULL ? *p : *reinterpret_cast<const ::nv::Embedding*>(
      &::nv::_Embedding_default_instance_);
}
inline ::nv::Embedding* Object::release_embedding() {
  // @@protoc_insertion_point(field_release:nv.Object.embedding)
  
  ::nv::Embedding* temp = embedding_;
  embedding_ = NULL;
  return temp;
}
inline ::nv::Embedding* Object::mutable_embedding() {
  
  if (embedding_ == NULL) {
    auto* p = CreateMaybeMessage<::nv::Embedding>(GetArenaNoVirtual());
    embedding_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nv.Object.embedding)
  return embedding_;
}
inline void Object::set_allocated_embedding(::nv::Embedding* embedding) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete embedding_;
  }
  if (embedding) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      embedding = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, embedding, submessage_arena);
    }
    
  } else {
    
  }
  embedding_ = embedding;
  // @@protoc_insertion_point(field_set_allocated:nv.Object.embedding)
}

// .nv.Pose pose = 7;
inline bool Object::has_pose() const {
  return this != internal_default_instance() && pose_ != NULL;
}
inline void Object::clear_pose() {
  if (GetArenaNoVirtual() == NULL && pose_ != NULL) {
    delete pose_;
  }
  pose_ = NULL;
}
inline const ::nv::Pose& Object::_internal_pose() const {
  return *pose_;
}
inline const ::nv::Pose& Object::pose() const {
  const ::nv::Pose* p = pose_;
  // @@protoc_insertion_point(field_get:nv.Object.pose)
  return p != NULL ? *p : *reinterpret_cast<const ::nv::Pose*>(
      &::nv::_Pose_default_instance_);
}
inline ::nv::Pose* Object::release_pose() {
  // @@protoc_insertion_point(field_release:nv.Object.pose)
  
  ::nv::Pose* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline ::nv::Pose* Object::mutable_pose() {
  
  if (pose_ == NULL) {
    auto* p = CreateMaybeMessage<::nv::Pose>(GetArenaNoVirtual());
    pose_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nv.Object.pose)
  return pose_;
}
inline void Object::set_allocated_pose(::nv::Pose* pose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pose_;
  }
  if (pose) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:nv.Object.pose)
}

// .nv.Gaze gaze = 8;
inline bool Object::has_gaze() const {
  return this != internal_default_instance() && gaze_ != NULL;
}
inline void Object::clear_gaze() {
  if (GetArenaNoVirtual() == NULL && gaze_ != NULL) {
    delete gaze_;
  }
  gaze_ = NULL;
}
inline const ::nv::Gaze& Object::_internal_gaze() const {
  return *gaze_;
}
inline const ::nv::Gaze& Object::gaze() const {
  const ::nv::Gaze* p = gaze_;
  // @@protoc_insertion_point(field_get:nv.Object.gaze)
  return p != NULL ? *p : *reinterpret_cast<const ::nv::Gaze*>(
      &::nv::_Gaze_default_instance_);
}
inline ::nv::Gaze* Object::release_gaze() {
  // @@protoc_insertion_point(field_release:nv.Object.gaze)
  
  ::nv::Gaze* temp = gaze_;
  gaze_ = NULL;
  return temp;
}
inline ::nv::Gaze* Object::mutable_gaze() {
  
  if (gaze_ == NULL) {
    auto* p = CreateMaybeMessage<::nv::Gaze>(GetArenaNoVirtual());
    gaze_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nv.Object.gaze)
  return gaze_;
}
inline void Object::set_allocated_gaze(::nv::Gaze* gaze) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete gaze_;
  }
  if (gaze) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      gaze = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gaze, submessage_arena);
    }
    
  } else {
    
  }
  gaze_ = gaze;
  // @@protoc_insertion_point(field_set_allocated:nv.Object.gaze)
}

// .nv.LipActivity lipActivity = 9;
inline bool Object::has_lipactivity() const {
  return this != internal_default_instance() && lipactivity_ != NULL;
}
inline void Object::clear_lipactivity() {
  if (GetArenaNoVirtual() == NULL && lipactivity_ != NULL) {
    delete lipactivity_;
  }
  lipactivity_ = NULL;
}
inline const ::nv::LipActivity& Object::_internal_lipactivity() const {
  return *lipactivity_;
}
inline const ::nv::LipActivity& Object::lipactivity() const {
  const ::nv::LipActivity* p = lipactivity_;
  // @@protoc_insertion_point(field_get:nv.Object.lipActivity)
  return p != NULL ? *p : *reinterpret_cast<const ::nv::LipActivity*>(
      &::nv::_LipActivity_default_instance_);
}
inline ::nv::LipActivity* Object::release_lipactivity() {
  // @@protoc_insertion_point(field_release:nv.Object.lipActivity)
  
  ::nv::LipActivity* temp = lipactivity_;
  lipactivity_ = NULL;
  return temp;
}
inline ::nv::LipActivity* Object::mutable_lipactivity() {
  
  if (lipactivity_ == NULL) {
    auto* p = CreateMaybeMessage<::nv::LipActivity>(GetArenaNoVirtual());
    lipactivity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nv.Object.lipActivity)
  return lipactivity_;
}
inline void Object::set_allocated_lipactivity(::nv::LipActivity* lipactivity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete lipactivity_;
  }
  if (lipactivity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lipactivity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lipactivity, submessage_arena);
    }
    
  } else {
    
  }
  lipactivity_ = lipactivity;
  // @@protoc_insertion_point(field_set_allocated:nv.Object.lipActivity)
}

// float speed = 10;
inline void Object::clear_speed() {
  speed_ = 0;
}
inline float Object::speed() const {
  // @@protoc_insertion_point(field_get:nv.Object.speed)
  return speed_;
}
inline void Object::set_speed(float value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:nv.Object.speed)
}

// repeated float dir = 11;
inline int Object::dir_size() const {
  return dir_.size();
}
inline void Object::clear_dir() {
  dir_.Clear();
}
inline float Object::dir(int index) const {
  // @@protoc_insertion_point(field_get:nv.Object.dir)
  return dir_.Get(index);
}
inline void Object::set_dir(int index, float value) {
  dir_.Set(index, value);
  // @@protoc_insertion_point(field_set:nv.Object.dir)
}
inline void Object::add_dir(float value) {
  dir_.Add(value);
  // @@protoc_insertion_point(field_add:nv.Object.dir)
}
inline const ::google::protobuf::RepeatedField< float >&
Object::dir() const {
  // @@protoc_insertion_point(field_list:nv.Object.dir)
  return dir_;
}
inline ::google::protobuf::RepeatedField< float >*
Object::mutable_dir() {
  // @@protoc_insertion_point(field_mutable_list:nv.Object.dir)
  return &dir_;
}

// .nv.Coordinate coordinate = 12;
inline bool Object::has_coordinate() const {
  return this != internal_default_instance() && coordinate_ != NULL;
}
inline void Object::clear_coordinate() {
  if (GetArenaNoVirtual() == NULL && coordinate_ != NULL) {
    delete coordinate_;
  }
  coordinate_ = NULL;
}
inline const ::nv::Coordinate& Object::_internal_coordinate() const {
  return *coordinate_;
}
inline const ::nv::Coordinate& Object::coordinate() const {
  const ::nv::Coordinate* p = coordinate_;
  // @@protoc_insertion_point(field_get:nv.Object.coordinate)
  return p != NULL ? *p : *reinterpret_cast<const ::nv::Coordinate*>(
      &::nv::_Coordinate_default_instance_);
}
inline ::nv::Coordinate* Object::release_coordinate() {
  // @@protoc_insertion_point(field_release:nv.Object.coordinate)
  
  ::nv::Coordinate* temp = coordinate_;
  coordinate_ = NULL;
  return temp;
}
inline ::nv::Coordinate* Object::mutable_coordinate() {
  
  if (coordinate_ == NULL) {
    auto* p = CreateMaybeMessage<::nv::Coordinate>(GetArenaNoVirtual());
    coordinate_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nv.Object.coordinate)
  return coordinate_;
}
inline void Object::set_allocated_coordinate(::nv::Coordinate* coordinate) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete coordinate_;
  }
  if (coordinate) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      coordinate = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, coordinate, submessage_arena);
    }
    
  } else {
    
  }
  coordinate_ = coordinate;
  // @@protoc_insertion_point(field_set_allocated:nv.Object.coordinate)
}

// .nv.Location location = 13;
inline bool Object::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline void Object::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) {
    delete location_;
  }
  location_ = NULL;
}
inline const ::nv::Location& Object::_internal_location() const {
  return *location_;
}
inline const ::nv::Location& Object::location() const {
  const ::nv::Location* p = location_;
  // @@protoc_insertion_point(field_get:nv.Object.location)
  return p != NULL ? *p : *reinterpret_cast<const ::nv::Location*>(
      &::nv::_Location_default_instance_);
}
inline ::nv::Location* Object::release_location() {
  // @@protoc_insertion_point(field_release:nv.Object.location)
  
  ::nv::Location* temp = location_;
  location_ = NULL;
  return temp;
}
inline ::nv::Location* Object::mutable_location() {
  
  if (location_ == NULL) {
    auto* p = CreateMaybeMessage<::nv::Location>(GetArenaNoVirtual());
    location_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nv.Object.location)
  return location_;
}
inline void Object::set_allocated_location(::nv::Location* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete location_;
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:nv.Object.location)
}

// -------------------------------------------------------------------

// Coordinate

// double x = 1;
inline void Coordinate::clear_x() {
  x_ = 0;
}
inline double Coordinate::x() const {
  // @@protoc_insertion_point(field_get:nv.Coordinate.x)
  return x_;
}
inline void Coordinate::set_x(double value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:nv.Coordinate.x)
}

// double y = 2;
inline void Coordinate::clear_y() {
  y_ = 0;
}
inline double Coordinate::y() const {
  // @@protoc_insertion_point(field_get:nv.Coordinate.y)
  return y_;
}
inline void Coordinate::set_y(double value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:nv.Coordinate.y)
}

// double z = 3;
inline void Coordinate::clear_z() {
  z_ = 0;
}
inline double Coordinate::z() const {
  // @@protoc_insertion_point(field_get:nv.Coordinate.z)
  return z_;
}
inline void Coordinate::set_z(double value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:nv.Coordinate.z)
}

// -------------------------------------------------------------------

// Location

// double lat = 1;
inline void Location::clear_lat() {
  lat_ = 0;
}
inline double Location::lat() const {
  // @@protoc_insertion_point(field_get:nv.Location.lat)
  return lat_;
}
inline void Location::set_lat(double value) {
  
  lat_ = value;
  // @@protoc_insertion_point(field_set:nv.Location.lat)
}

// double lon = 2;
inline void Location::clear_lon() {
  lon_ = 0;
}
inline double Location::lon() const {
  // @@protoc_insertion_point(field_get:nv.Location.lon)
  return lon_;
}
inline void Location::set_lon(double value) {
  
  lon_ = value;
  // @@protoc_insertion_point(field_set:nv.Location.lon)
}

// double alt = 3;
inline void Location::clear_alt() {
  alt_ = 0;
}
inline double Location::alt() const {
  // @@protoc_insertion_point(field_get:nv.Location.alt)
  return alt_;
}
inline void Location::set_alt(double value) {
  
  alt_ = value;
  // @@protoc_insertion_point(field_set:nv.Location.alt)
}

// -------------------------------------------------------------------

// Bbox

// float leftX = 1;
inline void Bbox::clear_leftx() {
  leftx_ = 0;
}
inline float Bbox::leftx() const {
  // @@protoc_insertion_point(field_get:nv.Bbox.leftX)
  return leftx_;
}
inline void Bbox::set_leftx(float value) {
  
  leftx_ = value;
  // @@protoc_insertion_point(field_set:nv.Bbox.leftX)
}

// float topY = 2;
inline void Bbox::clear_topy() {
  topy_ = 0;
}
inline float Bbox::topy() const {
  // @@protoc_insertion_point(field_get:nv.Bbox.topY)
  return topy_;
}
inline void Bbox::set_topy(float value) {
  
  topy_ = value;
  // @@protoc_insertion_point(field_set:nv.Bbox.topY)
}

// float rightX = 3;
inline void Bbox::clear_rightx() {
  rightx_ = 0;
}
inline float Bbox::rightx() const {
  // @@protoc_insertion_point(field_get:nv.Bbox.rightX)
  return rightx_;
}
inline void Bbox::set_rightx(float value) {
  
  rightx_ = value;
  // @@protoc_insertion_point(field_set:nv.Bbox.rightX)
}

// float bottomY = 4;
inline void Bbox::clear_bottomy() {
  bottomy_ = 0;
}
inline float Bbox::bottomy() const {
  // @@protoc_insertion_point(field_get:nv.Bbox.bottomY)
  return bottomy_;
}
inline void Bbox::set_bottomy(float value) {
  
  bottomy_ = value;
  // @@protoc_insertion_point(field_set:nv.Bbox.bottomY)
}

// -------------------------------------------------------------------

// Pose_Keypoint

// string name = 1;
inline void Pose_Keypoint::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Pose_Keypoint::name() const {
  // @@protoc_insertion_point(field_get:nv.Pose.Keypoint.name)
  return name_.GetNoArena();
}
inline void Pose_Keypoint::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nv.Pose.Keypoint.name)
}
#if LANG_CXX11
inline void Pose_Keypoint::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nv.Pose.Keypoint.name)
}
#endif
inline void Pose_Keypoint::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nv.Pose.Keypoint.name)
}
inline void Pose_Keypoint::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nv.Pose.Keypoint.name)
}
inline ::std::string* Pose_Keypoint::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:nv.Pose.Keypoint.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Pose_Keypoint::release_name() {
  // @@protoc_insertion_point(field_release:nv.Pose.Keypoint.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Pose_Keypoint::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:nv.Pose.Keypoint.name)
}

// repeated float coordinates = 2;
inline int Pose_Keypoint::coordinates_size() const {
  return coordinates_.size();
}
inline void Pose_Keypoint::clear_coordinates() {
  coordinates_.Clear();
}
inline float Pose_Keypoint::coordinates(int index) const {
  // @@protoc_insertion_point(field_get:nv.Pose.Keypoint.coordinates)
  return coordinates_.Get(index);
}
inline void Pose_Keypoint::set_coordinates(int index, float value) {
  coordinates_.Set(index, value);
  // @@protoc_insertion_point(field_set:nv.Pose.Keypoint.coordinates)
}
inline void Pose_Keypoint::add_coordinates(float value) {
  coordinates_.Add(value);
  // @@protoc_insertion_point(field_add:nv.Pose.Keypoint.coordinates)
}
inline const ::google::protobuf::RepeatedField< float >&
Pose_Keypoint::coordinates() const {
  // @@protoc_insertion_point(field_list:nv.Pose.Keypoint.coordinates)
  return coordinates_;
}
inline ::google::protobuf::RepeatedField< float >*
Pose_Keypoint::mutable_coordinates() {
  // @@protoc_insertion_point(field_mutable_list:nv.Pose.Keypoint.coordinates)
  return &coordinates_;
}

// repeated float quaternion = 3;
inline int Pose_Keypoint::quaternion_size() const {
  return quaternion_.size();
}
inline void Pose_Keypoint::clear_quaternion() {
  quaternion_.Clear();
}
inline float Pose_Keypoint::quaternion(int index) const {
  // @@protoc_insertion_point(field_get:nv.Pose.Keypoint.quaternion)
  return quaternion_.Get(index);
}
inline void Pose_Keypoint::set_quaternion(int index, float value) {
  quaternion_.Set(index, value);
  // @@protoc_insertion_point(field_set:nv.Pose.Keypoint.quaternion)
}
inline void Pose_Keypoint::add_quaternion(float value) {
  quaternion_.Add(value);
  // @@protoc_insertion_point(field_add:nv.Pose.Keypoint.quaternion)
}
inline const ::google::protobuf::RepeatedField< float >&
Pose_Keypoint::quaternion() const {
  // @@protoc_insertion_point(field_list:nv.Pose.Keypoint.quaternion)
  return quaternion_;
}
inline ::google::protobuf::RepeatedField< float >*
Pose_Keypoint::mutable_quaternion() {
  // @@protoc_insertion_point(field_mutable_list:nv.Pose.Keypoint.quaternion)
  return &quaternion_;
}

// -------------------------------------------------------------------

// Pose_Action

// string type = 1;
inline void Pose_Action::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Pose_Action::type() const {
  // @@protoc_insertion_point(field_get:nv.Pose.Action.type)
  return type_.GetNoArena();
}
inline void Pose_Action::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nv.Pose.Action.type)
}
#if LANG_CXX11
inline void Pose_Action::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nv.Pose.Action.type)
}
#endif
inline void Pose_Action::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nv.Pose.Action.type)
}
inline void Pose_Action::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nv.Pose.Action.type)
}
inline ::std::string* Pose_Action::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:nv.Pose.Action.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Pose_Action::release_type() {
  // @@protoc_insertion_point(field_release:nv.Pose.Action.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Pose_Action::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:nv.Pose.Action.type)
}

// float confidence = 2;
inline void Pose_Action::clear_confidence() {
  confidence_ = 0;
}
inline float Pose_Action::confidence() const {
  // @@protoc_insertion_point(field_get:nv.Pose.Action.confidence)
  return confidence_;
}
inline void Pose_Action::set_confidence(float value) {
  
  confidence_ = value;
  // @@protoc_insertion_point(field_set:nv.Pose.Action.confidence)
}

// -------------------------------------------------------------------

// Pose

// string type = 1;
inline void Pose::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Pose::type() const {
  // @@protoc_insertion_point(field_get:nv.Pose.type)
  return type_.GetNoArena();
}
inline void Pose::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nv.Pose.type)
}
#if LANG_CXX11
inline void Pose::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nv.Pose.type)
}
#endif
inline void Pose::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nv.Pose.type)
}
inline void Pose::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nv.Pose.type)
}
inline ::std::string* Pose::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:nv.Pose.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Pose::release_type() {
  // @@protoc_insertion_point(field_release:nv.Pose.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Pose::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:nv.Pose.type)
}

// repeated .nv.Pose.Keypoint keypoints = 2;
inline int Pose::keypoints_size() const {
  return keypoints_.size();
}
inline void Pose::clear_keypoints() {
  keypoints_.Clear();
}
inline ::nv::Pose_Keypoint* Pose::mutable_keypoints(int index) {
  // @@protoc_insertion_point(field_mutable:nv.Pose.keypoints)
  return keypoints_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nv::Pose_Keypoint >*
Pose::mutable_keypoints() {
  // @@protoc_insertion_point(field_mutable_list:nv.Pose.keypoints)
  return &keypoints_;
}
inline const ::nv::Pose_Keypoint& Pose::keypoints(int index) const {
  // @@protoc_insertion_point(field_get:nv.Pose.keypoints)
  return keypoints_.Get(index);
}
inline ::nv::Pose_Keypoint* Pose::add_keypoints() {
  // @@protoc_insertion_point(field_add:nv.Pose.keypoints)
  return keypoints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::Pose_Keypoint >&
Pose::keypoints() const {
  // @@protoc_insertion_point(field_list:nv.Pose.keypoints)
  return keypoints_;
}

// repeated .nv.Pose.Action actions = 3;
inline int Pose::actions_size() const {
  return actions_.size();
}
inline void Pose::clear_actions() {
  actions_.Clear();
}
inline ::nv::Pose_Action* Pose::mutable_actions(int index) {
  // @@protoc_insertion_point(field_mutable:nv.Pose.actions)
  return actions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nv::Pose_Action >*
Pose::mutable_actions() {
  // @@protoc_insertion_point(field_mutable_list:nv.Pose.actions)
  return &actions_;
}
inline const ::nv::Pose_Action& Pose::actions(int index) const {
  // @@protoc_insertion_point(field_get:nv.Pose.actions)
  return actions_.Get(index);
}
inline ::nv::Pose_Action* Pose::add_actions() {
  // @@protoc_insertion_point(field_add:nv.Pose.actions)
  return actions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::Pose_Action >&
Pose::actions() const {
  // @@protoc_insertion_point(field_list:nv.Pose.actions)
  return actions_;
}

// -------------------------------------------------------------------

// Gaze

// float x = 1;
inline void Gaze::clear_x() {
  x_ = 0;
}
inline float Gaze::x() const {
  // @@protoc_insertion_point(field_get:nv.Gaze.x)
  return x_;
}
inline void Gaze::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:nv.Gaze.x)
}

// float y = 2;
inline void Gaze::clear_y() {
  y_ = 0;
}
inline float Gaze::y() const {
  // @@protoc_insertion_point(field_get:nv.Gaze.y)
  return y_;
}
inline void Gaze::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:nv.Gaze.y)
}

// float z = 3;
inline void Gaze::clear_z() {
  z_ = 0;
}
inline float Gaze::z() const {
  // @@protoc_insertion_point(field_get:nv.Gaze.z)
  return z_;
}
inline void Gaze::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:nv.Gaze.z)
}

// float theta = 4;
inline void Gaze::clear_theta() {
  theta_ = 0;
}
inline float Gaze::theta() const {
  // @@protoc_insertion_point(field_get:nv.Gaze.theta)
  return theta_;
}
inline void Gaze::set_theta(float value) {
  
  theta_ = value;
  // @@protoc_insertion_point(field_set:nv.Gaze.theta)
}

// float phi = 5;
inline void Gaze::clear_phi() {
  phi_ = 0;
}
inline float Gaze::phi() const {
  // @@protoc_insertion_point(field_get:nv.Gaze.phi)
  return phi_;
}
inline void Gaze::set_phi(float value) {
  
  phi_ = value;
  // @@protoc_insertion_point(field_set:nv.Gaze.phi)
}

// -------------------------------------------------------------------

// LipActivity

// string classLabel = 1;
inline void LipActivity::clear_classlabel() {
  classlabel_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LipActivity::classlabel() const {
  // @@protoc_insertion_point(field_get:nv.LipActivity.classLabel)
  return classlabel_.GetNoArena();
}
inline void LipActivity::set_classlabel(const ::std::string& value) {
  
  classlabel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nv.LipActivity.classLabel)
}
#if LANG_CXX11
inline void LipActivity::set_classlabel(::std::string&& value) {
  
  classlabel_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nv.LipActivity.classLabel)
}
#endif
inline void LipActivity::set_classlabel(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  classlabel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nv.LipActivity.classLabel)
}
inline void LipActivity::set_classlabel(const char* value, size_t size) {
  
  classlabel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nv.LipActivity.classLabel)
}
inline ::std::string* LipActivity::mutable_classlabel() {
  
  // @@protoc_insertion_point(field_mutable:nv.LipActivity.classLabel)
  return classlabel_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LipActivity::release_classlabel() {
  // @@protoc_insertion_point(field_release:nv.LipActivity.classLabel)
  
  return classlabel_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LipActivity::set_allocated_classlabel(::std::string* classlabel) {
  if (classlabel != NULL) {
    
  } else {
    
  }
  classlabel_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), classlabel);
  // @@protoc_insertion_point(field_set_allocated:nv.LipActivity.classLabel)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Event

// string id = 1;
inline void Event::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Event::id() const {
  // @@protoc_insertion_point(field_get:nv.Event.id)
  return id_.GetNoArena();
}
inline void Event::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nv.Event.id)
}
#if LANG_CXX11
inline void Event::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nv.Event.id)
}
#endif
inline void Event::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nv.Event.id)
}
inline void Event::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nv.Event.id)
}
inline ::std::string* Event::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:nv.Event.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Event::release_id() {
  // @@protoc_insertion_point(field_release:nv.Event.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Event::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:nv.Event.id)
}

// string type = 2;
inline void Event::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Event::type() const {
  // @@protoc_insertion_point(field_get:nv.Event.type)
  return type_.GetNoArena();
}
inline void Event::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nv.Event.type)
}
#if LANG_CXX11
inline void Event::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nv.Event.type)
}
#endif
inline void Event::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nv.Event.type)
}
inline void Event::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nv.Event.type)
}
inline ::std::string* Event::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:nv.Event.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Event::release_type() {
  // @@protoc_insertion_point(field_release:nv.Event.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Event::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:nv.Event.type)
}

// map<string, string> info = 5;
inline int Event::info_size() const {
  return info_.size();
}
inline void Event::clear_info() {
  info_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
Event::info() const {
  // @@protoc_insertion_point(field_map:nv.Event.info)
  return info_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
Event::mutable_info() {
  // @@protoc_insertion_point(field_mutable_map:nv.Event.info)
  return info_.MutableMap();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// AnalyticsModule

// string id = 1;
inline void AnalyticsModule::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AnalyticsModule::id() const {
  // @@protoc_insertion_point(field_get:nv.AnalyticsModule.id)
  return id_.GetNoArena();
}
inline void AnalyticsModule::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nv.AnalyticsModule.id)
}
#if LANG_CXX11
inline void AnalyticsModule::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nv.AnalyticsModule.id)
}
#endif
inline void AnalyticsModule::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nv.AnalyticsModule.id)
}
inline void AnalyticsModule::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nv.AnalyticsModule.id)
}
inline ::std::string* AnalyticsModule::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:nv.AnalyticsModule.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AnalyticsModule::release_id() {
  // @@protoc_insertion_point(field_release:nv.AnalyticsModule.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AnalyticsModule::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:nv.AnalyticsModule.id)
}

// string description = 2;
inline void AnalyticsModule::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AnalyticsModule::description() const {
  // @@protoc_insertion_point(field_get:nv.AnalyticsModule.description)
  return description_.GetNoArena();
}
inline void AnalyticsModule::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nv.AnalyticsModule.description)
}
#if LANG_CXX11
inline void AnalyticsModule::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nv.AnalyticsModule.description)
}
#endif
inline void AnalyticsModule::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nv.AnalyticsModule.description)
}
inline void AnalyticsModule::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nv.AnalyticsModule.description)
}
inline ::std::string* AnalyticsModule::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:nv.AnalyticsModule.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AnalyticsModule::release_description() {
  // @@protoc_insertion_point(field_release:nv.AnalyticsModule.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AnalyticsModule::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:nv.AnalyticsModule.description)
}

// string source = 3;
inline void AnalyticsModule::clear_source() {
  source_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AnalyticsModule::source() const {
  // @@protoc_insertion_point(field_get:nv.AnalyticsModule.source)
  return source_.GetNoArena();
}
inline void AnalyticsModule::set_source(const ::std::string& value) {
  
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nv.AnalyticsModule.source)
}
#if LANG_CXX11
inline void AnalyticsModule::set_source(::std::string&& value) {
  
  source_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nv.AnalyticsModule.source)
}
#endif
inline void AnalyticsModule::set_source(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nv.AnalyticsModule.source)
}
inline void AnalyticsModule::set_source(const char* value, size_t size) {
  
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nv.AnalyticsModule.source)
}
inline ::std::string* AnalyticsModule::mutable_source() {
  
  // @@protoc_insertion_point(field_mutable:nv.AnalyticsModule.source)
  return source_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AnalyticsModule::release_source() {
  // @@protoc_insertion_point(field_release:nv.AnalyticsModule.source)
  
  return source_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AnalyticsModule::set_allocated_source(::std::string* source) {
  if (source != NULL) {
    
  } else {
    
  }
  source_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source);
  // @@protoc_insertion_point(field_set_allocated:nv.AnalyticsModule.source)
}

// string version = 4;
inline void AnalyticsModule::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AnalyticsModule::version() const {
  // @@protoc_insertion_point(field_get:nv.AnalyticsModule.version)
  return version_.GetNoArena();
}
inline void AnalyticsModule::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nv.AnalyticsModule.version)
}
#if LANG_CXX11
inline void AnalyticsModule::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nv.AnalyticsModule.version)
}
#endif
inline void AnalyticsModule::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nv.AnalyticsModule.version)
}
inline void AnalyticsModule::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nv.AnalyticsModule.version)
}
inline ::std::string* AnalyticsModule::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:nv.AnalyticsModule.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AnalyticsModule::release_version() {
  // @@protoc_insertion_point(field_release:nv.AnalyticsModule.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AnalyticsModule::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:nv.AnalyticsModule.version)
}

// map<string, string> info = 5;
inline int AnalyticsModule::info_size() const {
  return info_.size();
}
inline void AnalyticsModule::clear_info() {
  info_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
AnalyticsModule::info() const {
  // @@protoc_insertion_point(field_map:nv.AnalyticsModule.info)
  return info_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
AnalyticsModule::mutable_info() {
  // @@protoc_insertion_point(field_mutable_map:nv.AnalyticsModule.info)
  return info_.MutableMap();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Sensor

// string id = 1;
inline void Sensor::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Sensor::id() const {
  // @@protoc_insertion_point(field_get:nv.Sensor.id)
  return id_.GetNoArena();
}
inline void Sensor::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nv.Sensor.id)
}
#if LANG_CXX11
inline void Sensor::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nv.Sensor.id)
}
#endif
inline void Sensor::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nv.Sensor.id)
}
inline void Sensor::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nv.Sensor.id)
}
inline ::std::string* Sensor::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:nv.Sensor.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sensor::release_id() {
  // @@protoc_insertion_point(field_release:nv.Sensor.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sensor::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:nv.Sensor.id)
}

// string type = 2;
inline void Sensor::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Sensor::type() const {
  // @@protoc_insertion_point(field_get:nv.Sensor.type)
  return type_.GetNoArena();
}
inline void Sensor::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nv.Sensor.type)
}
#if LANG_CXX11
inline void Sensor::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nv.Sensor.type)
}
#endif
inline void Sensor::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nv.Sensor.type)
}
inline void Sensor::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nv.Sensor.type)
}
inline ::std::string* Sensor::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:nv.Sensor.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sensor::release_type() {
  // @@protoc_insertion_point(field_release:nv.Sensor.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sensor::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:nv.Sensor.type)
}

// string description = 3;
inline void Sensor::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Sensor::description() const {
  // @@protoc_insertion_point(field_get:nv.Sensor.description)
  return description_.GetNoArena();
}
inline void Sensor::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nv.Sensor.description)
}
#if LANG_CXX11
inline void Sensor::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nv.Sensor.description)
}
#endif
inline void Sensor::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nv.Sensor.description)
}
inline void Sensor::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nv.Sensor.description)
}
inline ::std::string* Sensor::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:nv.Sensor.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sensor::release_description() {
  // @@protoc_insertion_point(field_release:nv.Sensor.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sensor::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:nv.Sensor.description)
}

// .nv.Location location = 4;
inline bool Sensor::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline void Sensor::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) {
    delete location_;
  }
  location_ = NULL;
}
inline const ::nv::Location& Sensor::_internal_location() const {
  return *location_;
}
inline const ::nv::Location& Sensor::location() const {
  const ::nv::Location* p = location_;
  // @@protoc_insertion_point(field_get:nv.Sensor.location)
  return p != NULL ? *p : *reinterpret_cast<const ::nv::Location*>(
      &::nv::_Location_default_instance_);
}
inline ::nv::Location* Sensor::release_location() {
  // @@protoc_insertion_point(field_release:nv.Sensor.location)
  
  ::nv::Location* temp = location_;
  location_ = NULL;
  return temp;
}
inline ::nv::Location* Sensor::mutable_location() {
  
  if (location_ == NULL) {
    auto* p = CreateMaybeMessage<::nv::Location>(GetArenaNoVirtual());
    location_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nv.Sensor.location)
  return location_;
}
inline void Sensor::set_allocated_location(::nv::Location* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete location_;
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:nv.Sensor.location)
}

// .nv.Coordinate coordinate = 5;
inline bool Sensor::has_coordinate() const {
  return this != internal_default_instance() && coordinate_ != NULL;
}
inline void Sensor::clear_coordinate() {
  if (GetArenaNoVirtual() == NULL && coordinate_ != NULL) {
    delete coordinate_;
  }
  coordinate_ = NULL;
}
inline const ::nv::Coordinate& Sensor::_internal_coordinate() const {
  return *coordinate_;
}
inline const ::nv::Coordinate& Sensor::coordinate() const {
  const ::nv::Coordinate* p = coordinate_;
  // @@protoc_insertion_point(field_get:nv.Sensor.coordinate)
  return p != NULL ? *p : *reinterpret_cast<const ::nv::Coordinate*>(
      &::nv::_Coordinate_default_instance_);
}
inline ::nv::Coordinate* Sensor::release_coordinate() {
  // @@protoc_insertion_point(field_release:nv.Sensor.coordinate)
  
  ::nv::Coordinate* temp = coordinate_;
  coordinate_ = NULL;
  return temp;
}
inline ::nv::Coordinate* Sensor::mutable_coordinate() {
  
  if (coordinate_ == NULL) {
    auto* p = CreateMaybeMessage<::nv::Coordinate>(GetArenaNoVirtual());
    coordinate_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nv.Sensor.coordinate)
  return coordinate_;
}
inline void Sensor::set_allocated_coordinate(::nv::Coordinate* coordinate) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete coordinate_;
  }
  if (coordinate) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      coordinate = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, coordinate, submessage_arena);
    }
    
  } else {
    
  }
  coordinate_ = coordinate;
  // @@protoc_insertion_point(field_set_allocated:nv.Sensor.coordinate)
}

// map<string, string> info = 6;
inline int Sensor::info_size() const {
  return info_.size();
}
inline void Sensor::clear_info() {
  info_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
Sensor::info() const {
  // @@protoc_insertion_point(field_map:nv.Sensor.info)
  return info_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
Sensor::mutable_info() {
  // @@protoc_insertion_point(field_mutable_map:nv.Sensor.info)
  return info_.MutableMap();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Place

// string id = 1;
inline void Place::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Place::id() const {
  // @@protoc_insertion_point(field_get:nv.Place.id)
  return id_.GetNoArena();
}
inline void Place::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nv.Place.id)
}
#if LANG_CXX11
inline void Place::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nv.Place.id)
}
#endif
inline void Place::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nv.Place.id)
}
inline void Place::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nv.Place.id)
}
inline ::std::string* Place::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:nv.Place.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Place::release_id() {
  // @@protoc_insertion_point(field_release:nv.Place.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Place::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:nv.Place.id)
}

// string name = 2;
inline void Place::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Place::name() const {
  // @@protoc_insertion_point(field_get:nv.Place.name)
  return name_.GetNoArena();
}
inline void Place::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nv.Place.name)
}
#if LANG_CXX11
inline void Place::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nv.Place.name)
}
#endif
inline void Place::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nv.Place.name)
}
inline void Place::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nv.Place.name)
}
inline ::std::string* Place::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:nv.Place.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Place::release_name() {
  // @@protoc_insertion_point(field_release:nv.Place.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Place::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:nv.Place.name)
}

// string type = 3;
inline void Place::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Place::type() const {
  // @@protoc_insertion_point(field_get:nv.Place.type)
  return type_.GetNoArena();
}
inline void Place::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nv.Place.type)
}
#if LANG_CXX11
inline void Place::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nv.Place.type)
}
#endif
inline void Place::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nv.Place.type)
}
inline void Place::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nv.Place.type)
}
inline ::std::string* Place::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:nv.Place.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Place::release_type() {
  // @@protoc_insertion_point(field_release:nv.Place.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Place::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:nv.Place.type)
}

// .nv.Location location = 4;
inline bool Place::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline void Place::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) {
    delete location_;
  }
  location_ = NULL;
}
inline const ::nv::Location& Place::_internal_location() const {
  return *location_;
}
inline const ::nv::Location& Place::location() const {
  const ::nv::Location* p = location_;
  // @@protoc_insertion_point(field_get:nv.Place.location)
  return p != NULL ? *p : *reinterpret_cast<const ::nv::Location*>(
      &::nv::_Location_default_instance_);
}
inline ::nv::Location* Place::release_location() {
  // @@protoc_insertion_point(field_release:nv.Place.location)
  
  ::nv::Location* temp = location_;
  location_ = NULL;
  return temp;
}
inline ::nv::Location* Place::mutable_location() {
  
  if (location_ == NULL) {
    auto* p = CreateMaybeMessage<::nv::Location>(GetArenaNoVirtual());
    location_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nv.Place.location)
  return location_;
}
inline void Place::set_allocated_location(::nv::Location* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete location_;
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:nv.Place.location)
}

// .nv.Coordinate coordinate = 5;
inline bool Place::has_coordinate() const {
  return this != internal_default_instance() && coordinate_ != NULL;
}
inline void Place::clear_coordinate() {
  if (GetArenaNoVirtual() == NULL && coordinate_ != NULL) {
    delete coordinate_;
  }
  coordinate_ = NULL;
}
inline const ::nv::Coordinate& Place::_internal_coordinate() const {
  return *coordinate_;
}
inline const ::nv::Coordinate& Place::coordinate() const {
  const ::nv::Coordinate* p = coordinate_;
  // @@protoc_insertion_point(field_get:nv.Place.coordinate)
  return p != NULL ? *p : *reinterpret_cast<const ::nv::Coordinate*>(
      &::nv::_Coordinate_default_instance_);
}
inline ::nv::Coordinate* Place::release_coordinate() {
  // @@protoc_insertion_point(field_release:nv.Place.coordinate)
  
  ::nv::Coordinate* temp = coordinate_;
  coordinate_ = NULL;
  return temp;
}
inline ::nv::Coordinate* Place::mutable_coordinate() {
  
  if (coordinate_ == NULL) {
    auto* p = CreateMaybeMessage<::nv::Coordinate>(GetArenaNoVirtual());
    coordinate_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nv.Place.coordinate)
  return coordinate_;
}
inline void Place::set_allocated_coordinate(::nv::Coordinate* coordinate) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete coordinate_;
  }
  if (coordinate) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      coordinate = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, coordinate, submessage_arena);
    }
    
  } else {
    
  }
  coordinate_ = coordinate;
  // @@protoc_insertion_point(field_set_allocated:nv.Place.coordinate)
}

// map<string, string> info = 6;
inline int Place::info_size() const {
  return info_.size();
}
inline void Place::clear_info() {
  info_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
Place::info() const {
  // @@protoc_insertion_point(field_map:nv.Place.info)
  return info_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
Place::mutable_info() {
  // @@protoc_insertion_point(field_mutable_map:nv.Place.info)
  return info_.MutableMap();
}

// -------------------------------------------------------------------

// Message

// string messageid = 1;
inline void Message::clear_messageid() {
  messageid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Message::messageid() const {
  // @@protoc_insertion_point(field_get:nv.Message.messageid)
  return messageid_.GetNoArena();
}
inline void Message::set_messageid(const ::std::string& value) {
  
  messageid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nv.Message.messageid)
}
#if LANG_CXX11
inline void Message::set_messageid(::std::string&& value) {
  
  messageid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nv.Message.messageid)
}
#endif
inline void Message::set_messageid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  messageid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nv.Message.messageid)
}
inline void Message::set_messageid(const char* value, size_t size) {
  
  messageid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nv.Message.messageid)
}
inline ::std::string* Message::mutable_messageid() {
  
  // @@protoc_insertion_point(field_mutable:nv.Message.messageid)
  return messageid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message::release_messageid() {
  // @@protoc_insertion_point(field_release:nv.Message.messageid)
  
  return messageid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_messageid(::std::string* messageid) {
  if (messageid != NULL) {
    
  } else {
    
  }
  messageid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), messageid);
  // @@protoc_insertion_point(field_set_allocated:nv.Message.messageid)
}

// string mdsversion = 2;
inline void Message::clear_mdsversion() {
  mdsversion_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Message::mdsversion() const {
  // @@protoc_insertion_point(field_get:nv.Message.mdsversion)
  return mdsversion_.GetNoArena();
}
inline void Message::set_mdsversion(const ::std::string& value) {
  
  mdsversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nv.Message.mdsversion)
}
#if LANG_CXX11
inline void Message::set_mdsversion(::std::string&& value) {
  
  mdsversion_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nv.Message.mdsversion)
}
#endif
inline void Message::set_mdsversion(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mdsversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nv.Message.mdsversion)
}
inline void Message::set_mdsversion(const char* value, size_t size) {
  
  mdsversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nv.Message.mdsversion)
}
inline ::std::string* Message::mutable_mdsversion() {
  
  // @@protoc_insertion_point(field_mutable:nv.Message.mdsversion)
  return mdsversion_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message::release_mdsversion() {
  // @@protoc_insertion_point(field_release:nv.Message.mdsversion)
  
  return mdsversion_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_mdsversion(::std::string* mdsversion) {
  if (mdsversion != NULL) {
    
  } else {
    
  }
  mdsversion_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mdsversion);
  // @@protoc_insertion_point(field_set_allocated:nv.Message.mdsversion)
}

// .google.protobuf.Timestamp timestamp = 3;
inline bool Message::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline const ::google::protobuf::Timestamp& Message::_internal_timestamp() const {
  return *timestamp_;
}
inline const ::google::protobuf::Timestamp& Message::timestamp() const {
  const ::google::protobuf::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:nv.Message.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* Message::release_timestamp() {
  // @@protoc_insertion_point(field_release:nv.Message.timestamp)
  
  ::google::protobuf::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* Message::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    timestamp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nv.Message.timestamp)
  return timestamp_;
}
inline void Message::set_allocated_timestamp(::google::protobuf::Timestamp* timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:nv.Message.timestamp)
}

// .nv.Place place = 4;
inline bool Message::has_place() const {
  return this != internal_default_instance() && place_ != NULL;
}
inline void Message::clear_place() {
  if (GetArenaNoVirtual() == NULL && place_ != NULL) {
    delete place_;
  }
  place_ = NULL;
}
inline const ::nv::Place& Message::_internal_place() const {
  return *place_;
}
inline const ::nv::Place& Message::place() const {
  const ::nv::Place* p = place_;
  // @@protoc_insertion_point(field_get:nv.Message.place)
  return p != NULL ? *p : *reinterpret_cast<const ::nv::Place*>(
      &::nv::_Place_default_instance_);
}
inline ::nv::Place* Message::release_place() {
  // @@protoc_insertion_point(field_release:nv.Message.place)
  
  ::nv::Place* temp = place_;
  place_ = NULL;
  return temp;
}
inline ::nv::Place* Message::mutable_place() {
  
  if (place_ == NULL) {
    auto* p = CreateMaybeMessage<::nv::Place>(GetArenaNoVirtual());
    place_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nv.Message.place)
  return place_;
}
inline void Message::set_allocated_place(::nv::Place* place) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete place_;
  }
  if (place) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      place = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, place, submessage_arena);
    }
    
  } else {
    
  }
  place_ = place;
  // @@protoc_insertion_point(field_set_allocated:nv.Message.place)
}

// .nv.Sensor sensor = 5;
inline bool Message::has_sensor() const {
  return this != internal_default_instance() && sensor_ != NULL;
}
inline void Message::clear_sensor() {
  if (GetArenaNoVirtual() == NULL && sensor_ != NULL) {
    delete sensor_;
  }
  sensor_ = NULL;
}
inline const ::nv::Sensor& Message::_internal_sensor() const {
  return *sensor_;
}
inline const ::nv::Sensor& Message::sensor() const {
  const ::nv::Sensor* p = sensor_;
  // @@protoc_insertion_point(field_get:nv.Message.sensor)
  return p != NULL ? *p : *reinterpret_cast<const ::nv::Sensor*>(
      &::nv::_Sensor_default_instance_);
}
inline ::nv::Sensor* Message::release_sensor() {
  // @@protoc_insertion_point(field_release:nv.Message.sensor)
  
  ::nv::Sensor* temp = sensor_;
  sensor_ = NULL;
  return temp;
}
inline ::nv::Sensor* Message::mutable_sensor() {
  
  if (sensor_ == NULL) {
    auto* p = CreateMaybeMessage<::nv::Sensor>(GetArenaNoVirtual());
    sensor_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nv.Message.sensor)
  return sensor_;
}
inline void Message::set_allocated_sensor(::nv::Sensor* sensor) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sensor_;
  }
  if (sensor) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sensor = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sensor, submessage_arena);
    }
    
  } else {
    
  }
  sensor_ = sensor;
  // @@protoc_insertion_point(field_set_allocated:nv.Message.sensor)
}

// .nv.AnalyticsModule analyticsModule = 6;
inline bool Message::has_analyticsmodule() const {
  return this != internal_default_instance() && analyticsmodule_ != NULL;
}
inline void Message::clear_analyticsmodule() {
  if (GetArenaNoVirtual() == NULL && analyticsmodule_ != NULL) {
    delete analyticsmodule_;
  }
  analyticsmodule_ = NULL;
}
inline const ::nv::AnalyticsModule& Message::_internal_analyticsmodule() const {
  return *analyticsmodule_;
}
inline const ::nv::AnalyticsModule& Message::analyticsmodule() const {
  const ::nv::AnalyticsModule* p = analyticsmodule_;
  // @@protoc_insertion_point(field_get:nv.Message.analyticsModule)
  return p != NULL ? *p : *reinterpret_cast<const ::nv::AnalyticsModule*>(
      &::nv::_AnalyticsModule_default_instance_);
}
inline ::nv::AnalyticsModule* Message::release_analyticsmodule() {
  // @@protoc_insertion_point(field_release:nv.Message.analyticsModule)
  
  ::nv::AnalyticsModule* temp = analyticsmodule_;
  analyticsmodule_ = NULL;
  return temp;
}
inline ::nv::AnalyticsModule* Message::mutable_analyticsmodule() {
  
  if (analyticsmodule_ == NULL) {
    auto* p = CreateMaybeMessage<::nv::AnalyticsModule>(GetArenaNoVirtual());
    analyticsmodule_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nv.Message.analyticsModule)
  return analyticsmodule_;
}
inline void Message::set_allocated_analyticsmodule(::nv::AnalyticsModule* analyticsmodule) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete analyticsmodule_;
  }
  if (analyticsmodule) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      analyticsmodule = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, analyticsmodule, submessage_arena);
    }
    
  } else {
    
  }
  analyticsmodule_ = analyticsmodule;
  // @@protoc_insertion_point(field_set_allocated:nv.Message.analyticsModule)
}

// .nv.Object object = 7;
inline bool Message::has_object() const {
  return this != internal_default_instance() && object_ != NULL;
}
inline void Message::clear_object() {
  if (GetArenaNoVirtual() == NULL && object_ != NULL) {
    delete object_;
  }
  object_ = NULL;
}
inline const ::nv::Object& Message::_internal_object() const {
  return *object_;
}
inline const ::nv::Object& Message::object() const {
  const ::nv::Object* p = object_;
  // @@protoc_insertion_point(field_get:nv.Message.object)
  return p != NULL ? *p : *reinterpret_cast<const ::nv::Object*>(
      &::nv::_Object_default_instance_);
}
inline ::nv::Object* Message::release_object() {
  // @@protoc_insertion_point(field_release:nv.Message.object)
  
  ::nv::Object* temp = object_;
  object_ = NULL;
  return temp;
}
inline ::nv::Object* Message::mutable_object() {
  
  if (object_ == NULL) {
    auto* p = CreateMaybeMessage<::nv::Object>(GetArenaNoVirtual());
    object_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nv.Message.object)
  return object_;
}
inline void Message::set_allocated_object(::nv::Object* object) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete object_;
  }
  if (object) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      object = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:nv.Message.object)
}

// .nv.Event event = 8;
inline bool Message::has_event() const {
  return this != internal_default_instance() && event_ != NULL;
}
inline void Message::clear_event() {
  if (GetArenaNoVirtual() == NULL && event_ != NULL) {
    delete event_;
  }
  event_ = NULL;
}
inline const ::nv::Event& Message::_internal_event() const {
  return *event_;
}
inline const ::nv::Event& Message::event() const {
  const ::nv::Event* p = event_;
  // @@protoc_insertion_point(field_get:nv.Message.event)
  return p != NULL ? *p : *reinterpret_cast<const ::nv::Event*>(
      &::nv::_Event_default_instance_);
}
inline ::nv::Event* Message::release_event() {
  // @@protoc_insertion_point(field_release:nv.Message.event)
  
  ::nv::Event* temp = event_;
  event_ = NULL;
  return temp;
}
inline ::nv::Event* Message::mutable_event() {
  
  if (event_ == NULL) {
    auto* p = CreateMaybeMessage<::nv::Event>(GetArenaNoVirtual());
    event_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nv.Message.event)
  return event_;
}
inline void Message::set_allocated_event(::nv::Event* event) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete event_;
  }
  if (event) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      event = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, event, submessage_arena);
    }
    
  } else {
    
  }
  event_ = event;
  // @@protoc_insertion_point(field_set_allocated:nv.Message.event)
}

// string videoPath = 9;
inline void Message::clear_videopath() {
  videopath_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Message::videopath() const {
  // @@protoc_insertion_point(field_get:nv.Message.videoPath)
  return videopath_.GetNoArena();
}
inline void Message::set_videopath(const ::std::string& value) {
  
  videopath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nv.Message.videoPath)
}
#if LANG_CXX11
inline void Message::set_videopath(::std::string&& value) {
  
  videopath_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nv.Message.videoPath)
}
#endif
inline void Message::set_videopath(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  videopath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nv.Message.videoPath)
}
inline void Message::set_videopath(const char* value, size_t size) {
  
  videopath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nv.Message.videoPath)
}
inline ::std::string* Message::mutable_videopath() {
  
  // @@protoc_insertion_point(field_mutable:nv.Message.videoPath)
  return videopath_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message::release_videopath() {
  // @@protoc_insertion_point(field_release:nv.Message.videoPath)
  
  return videopath_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_videopath(::std::string* videopath) {
  if (videopath != NULL) {
    
  } else {
    
  }
  videopath_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), videopath);
  // @@protoc_insertion_point(field_set_allocated:nv.Message.videoPath)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Embedding

// repeated float vector = 1 [packed = true];
inline int Embedding::vector_size() const {
  return vector_.size();
}
inline void Embedding::clear_vector() {
  vector_.Clear();
}
inline float Embedding::vector(int index) const {
  // @@protoc_insertion_point(field_get:nv.Embedding.vector)
  return vector_.Get(index);
}
inline void Embedding::set_vector(int index, float value) {
  vector_.Set(index, value);
  // @@protoc_insertion_point(field_set:nv.Embedding.vector)
}
inline void Embedding::add_vector(float value) {
  vector_.Add(value);
  // @@protoc_insertion_point(field_add:nv.Embedding.vector)
}
inline const ::google::protobuf::RepeatedField< float >&
Embedding::vector() const {
  // @@protoc_insertion_point(field_list:nv.Embedding.vector)
  return vector_;
}
inline ::google::protobuf::RepeatedField< float >*
Embedding::mutable_vector() {
  // @@protoc_insertion_point(field_mutable_list:nv.Embedding.vector)
  return &vector_;
}

// map<string, string> info = 2;
inline int Embedding::info_size() const {
  return info_.size();
}
inline void Embedding::clear_info() {
  info_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
Embedding::info() const {
  // @@protoc_insertion_point(field_map:nv.Embedding.info)
  return info_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
Embedding::mutable_info() {
  // @@protoc_insertion_point(field_mutable_map:nv.Embedding.info)
  return info_.MutableMap();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace nv

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_schema_2eproto
